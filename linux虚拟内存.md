# 一、虚拟内存
## 1.1 问题: 一个程序不能访问另外一个程序的地址指向的空间.
理解:
- (1) 每个程序的开始地址0x80084000
- (2) 程序中使用的地址不是物理,而是逻辑地址(虚拟内存)。逻辑地址仅仅是编号，编号使用int 4字节整数表示 4294967296 每个程序提供了4G的访问能力
## 1.2 问题: 逻辑地址与物理地址关联才有意义:过程称为内存映射.
### 1.2.1 背景:
虚拟内存的提出: 禁止用户直接访问物理存储设备，有助于系统的稳定.
## 1.3 结论:
虚拟地址与物理地址映射的时候有一个基本单位: 4k  1000 内存页.
- 段错误: 无效访问.
- 合法访问: 比如malloc分配的空间之外的空间可以访问, 但访问非法.
# 二、虚拟内存的分配
- 栈: 编译器自动生成代码维护。
- 堆: 地址是否映射,映射的空间是否被管理。
brk/sbrk内存映射函数
## 2.1 分配释放内存:
```Shell
int   brk(void *end); //分配空间,释放空间
void* sbrk(int size); //返回空间地址
```
## 2.2 应用:
1. 使用sbrk分配空间 size为正：分配空间； size为负：可释放空间
2. 使用sbrk得到没有映射的虚拟地址.
3. 使用brk分配空间
4. 使用brk释放空间
## 2.3 理解:
sbrk(int  size)；sbrk 与brk后台系统维护一个指针。指针默认是null。调用sbrk,判定指针是否是0,是:得到大块空闲空间的首地址初始化指针.同时把指针+size；否:返回指针,并且把指针位置+size。
# 三、例子：Linux下
## 3.1 代码1：
```Shell
#include<stdio.h>
#include<unistd.h>
void main() {
     int * p1=sbrk(0);     // 得到大块空闲空间的首地址初始化指针
     int * p2=sbrk(4);     // 分配4个字节的空间先返回空闲空间的首地址，在将指针加4
     int * p3=sbrk(4);     // 同理，返回的指针地址为上一次sbrk返回的地址+size

     printf(“%p\n”,p1);
     printf(“%p\n”,p2);
     printf(“%p\n”,p3);
}
```
运行结果：
##### 0x18de000     sbrk(0)返回的空闲空间首地址
##### 0x18de000     sbrk(4)返回的空间地址，并把地址+size（0x18de004）{0x18de000-0x18de004 为sbrk(4)分配的4个字节的空间，返回空间首地址就是 0x18de000}
##### 0x18de004     sbrk(4)再次调用sbrk(4)，返回的指针为地址 0x18de004,指针再次+size{0x18de004-0x18de008 为这次调用sbrk分配的4个字节的空间}
## 3.2 代码2

